var SquareVerifier = artifacts.require("SquareVerifier");
var SolnSquareVerifier = artifacts.require("SolnSquareVerifier");
const proof = require("../../zokrates/code/square/proof.json");

contract("SolnSquareVerifier", (accounts) => {
  let soln;
  let verifier;

  function mintWithValidProof1() {
    return soln.mint(
      accounts[0],
      proof.proof.a,
      proof.proof.b,
      proof.proof.c,
      proof.inputs
    );
  }

  describe("Test verification with proof generated by Zokrates", () => {
    beforeEach(async () => {
      verifier = await SquareVerifier.new({ from: accounts[0] });
      soln = await SolnSquareVerifier.new(accounts[0]);
    });

    // Test if a new solution can be added for contract - SolnSquareVerifier
    it("if a new solution can be added for contract", async function () {
      let canAdd = true;
      try {
        await soln.canMintToken(
          accounts[0],
          proof.proof.a,
          proof.proof.b,
          proof.proof.c,
          proof.inputs
        );
      } catch (e) {
        canAdd = false;
      }
      assert.equal(canAdd, true, "Solution cannot be added");
    });

    // Test if an ERC721 token can be minted for contract - SolnSquareVerifier
    it("Can mint a ERC721 if the proof is valid", async () => {
      await mintWithValidProof1();
      assert.equal(await soln.totalSupply(), 1);
    });

    it("reverts if proof is not valid", async () => {
      let isReverted = false;
      try {
        const cheatInput = [123, 123];
        await soln.mint(
          accounts[0],
          proof.proof.a,
          proof.proof.b,
          proof.proof.c,
          cheatInput
        );
      } catch (error) {
        isReverted = true;
      }
      assert.equal(isReverted, true);
    });
  });
});
